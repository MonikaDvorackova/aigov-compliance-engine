name: compliance

"on":
  pull_request:
  push:
    branches: [main]

permissions:
  contents: read

concurrency:
  group: compliance-${{ github.ref }}
  cancel-in-progress: true

jobs:
  make-verify:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Verify Makefile exists
        run: |
          test -f Makefile
          echo ok

      - name: Verify Makefile targets parse
        run: |
          make -n promote RUN_ID=dummy >/dev/null
          make -n audit-object RUN_ID=dummy >/dev/null 2>&1 || true
          make -n evidence-pack RUN_ID=dummy >/dev/null 2>&1 || true

  reports-present:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Ensure reports and audit directories exist
        run: |
          mkdir -p docs/reports
          mkdir -p docs/audit
          mkdir -p docs/packs
          mkdir -p docs/policy
          ls -la docs/reports | head -n 50
          ls -la docs/audit | head -n 50
          ls -la docs/packs | head -n 50
          ls -la docs/policy | head -n 50

  report-gate:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Require policy scope file exists
        shell: bash
        run: |
          set -euo pipefail
          test -f docs/policy/scope.txt
          echo ok

      - name: Require new audit report and audit object when scoped files change
        shell: bash
        run: |
          set -euo pipefail

          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          echo "Policy scope patterns (docs/policy/scope.txt):"
          sed -n '1,200p' docs/policy/scope.txt

          echo "Changed files:"
          git diff --name-only "${BASE_SHA}" "${HEAD_SHA}"

          NEED_EVIDENCE=0
          MATCHED_SCOPE=""

          while IFS= read -r pat; do
            pat="$(echo "$pat" | tr -d '\r' | sed 's/#.*$//')"
            [ -z "$pat" ] && continue

            if git diff --name-only "${BASE_SHA}" "${HEAD_SHA}" -- "$pat" | grep -q .; then
              NEED_EVIDENCE=1
              MATCHED_SCOPE="$pat"
              break
            fi
          done < docs/policy/scope.txt

          if [ "$NEED_EVIDENCE" -eq 0 ]; then
            echo "No policy relevant changes detected"
            exit 0
          fi

          echo "Policy relevant change matched scope: $MATCHED_SCOPE"

          NEW_REPORTS="$(git diff --name-only --diff-filter=A "${BASE_SHA}" "${HEAD_SHA}" -- 'docs/reports/**' || true)"
          echo "New reports:"
          echo "$NEW_REPORTS"
          if [ -z "$NEW_REPORTS" ]; then
            echo "Audit report required: add a new file under docs/reports"
            exit 2
          fi

          NEW_AUDIT_OBJECTS="$(git diff --name-only --diff-filter=A "${BASE_SHA}" "${HEAD_SHA}" -- 'docs/audit/**' || true)"
          echo "New audit objects:"
          echo "$NEW_AUDIT_OBJECTS"
          if [ -z "$NEW_AUDIT_OBJECTS" ]; then
            echo "Audit object required: add a new file under docs/audit"
            exit 2
          fi

          echo "Evidence gate passed"

  report-content:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    needs: [report-gate]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Validate evidence filenames, report fields, and audit object content
        shell: bash
        run: |
          set -euo pipefail

          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          NEW_REPORTS="$(git diff --name-only --diff-filter=A "${BASE_SHA}" "${HEAD_SHA}" -- 'docs/reports/**' || true)"
          NEW_AUDIT_OBJECTS="$(git diff --name-only --diff-filter=A "${BASE_SHA}" "${HEAD_SHA}" -- 'docs/audit/**' || true)"

          echo "New reports:"
          echo "$NEW_REPORTS"
          echo "New audit objects:"
          echo "$NEW_AUDIT_OBJECTS"

          UUID_RE='[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}'
          SHA_RE='[0-9a-f]{64}'

          FAIL=0

          for f in $NEW_REPORTS; do
            case "$f" in
              *.md|*.txt) : ;;
              *)
                echo "Report must be .md or .txt: $f"
                FAIL=1
                continue
                ;;
            esac

            bn="$(basename "$f")"
            if ! echo "$bn" | grep -Eq "^${UUID_RE}\.(md|txt)$"; then
              echo "Report filename must be <run_id>.md or <run_id>.txt: $f"
              FAIL=1
            fi
          done

          for f in $NEW_AUDIT_OBJECTS; do
            case "$f" in
              *.json) : ;;
              *)
                echo "Audit object must be .json: $f"
                FAIL=1
                ;;
            esac

            bn="$(basename "$f")"
            if ! echo "$bn" | grep -Eq "^${UUID_RE}\.json$"; then
              echo "Audit object filename must be <run_id>.json: $f"
              FAIL=1
            fi
          done

          MOD_REPORTS="$(git diff --name-only --diff-filter=MR "${BASE_SHA}" "${HEAD_SHA}" -- 'docs/reports/**' || true)"
          MOD_AUDIT="$(git diff --name-only --diff-filter=MR "${BASE_SHA}" "${HEAD_SHA}" -- 'docs/audit/**' || true)"
          if [ -n "$MOD_REPORTS" ]; then
            echo "Modifying or renaming existing reports is forbidden:"
            echo "$MOD_REPORTS"
            FAIL=1
          fi
          if [ -n "$MOD_AUDIT" ]; then
            echo "Modifying or renaming existing audit objects is forbidden:"
            echo "$MOD_AUDIT"
            FAIL=1
          fi

          DEL_REPORTS="$(git diff --name-only --diff-filter=D "${BASE_SHA}" "${HEAD_SHA}" -- 'docs/reports/**' || true)"
          DEL_AUDIT="$(git diff --name-only --diff-filter=D "${BASE_SHA}" "${HEAD_SHA}" -- 'docs/audit/**' || true)"
          if [ -n "$DEL_REPORTS" ]; then
            echo "Deleting existing reports is forbidden:"
            echo "$DEL_REPORTS"
            FAIL=1
          fi
          if [ -n "$DEL_AUDIT" ]; then
            echo "Deleting existing audit objects is forbidden:"
            echo "$DEL_AUDIT"
            FAIL=1
          fi

          for f in $NEW_REPORTS; do
            echo "Checking report $f"

            if ! grep -Eq "^run_id=${UUID_RE}$" "$f"; then
              echo "Missing or invalid run_id line in $f"
              FAIL=1
            fi

            if ! grep -Eq "^bundle_sha256=${SHA_RE}$" "$f"; then
              echo "Missing or invalid bundle_sha256 line in $f"
              FAIL=1
            fi

            if ! grep -Eq "^policy_version=.+$" "$f"; then
              echo "Missing or invalid policy_version line in $f"
              FAIL=1
            fi
          done

          for f in $NEW_AUDIT_OBJECTS; do
            echo "Checking audit object $f"
            PYFILE="$f" python -c 'import os,json; p=os.environ["PYFILE"]; o=json.load(open(p,"r",encoding="utf-8")); assert isinstance(o,dict); assert isinstance(o.get("run_id"),str) and o["run_id"]; assert isinstance(o.get("bundle_sha256"),str) and o["bundle_sha256"]; print("ok")' || FAIL=1
          done

          for f in $NEW_REPORTS; do
            RUN_ID="$(grep -E "^run_id=" "$f" | head -n 1 | cut -d= -f2 | tr -d "\r\n")"
            R_SHA="$(grep -E "^bundle_sha256=" "$f" | head -n 1 | cut -d= -f2 | tr -d "\r\n")"

            if [ -z "$RUN_ID" ] || [ -z "$R_SHA" ]; then
              echo "Could not extract run_id or bundle_sha256 from $f"
              FAIL=1
              continue
            fi

            AUDIT_OBJ="docs/audit/${RUN_ID}.json"
            if [ ! -f "$AUDIT_OBJ" ]; then
              echo "Missing required audit object ${AUDIT_OBJ} for report $f"
              FAIL=1
              continue
            fi

            RUN_ID_ENV="$RUN_ID" R_SHA_ENV="$R_SHA" AUDIT_OBJ_ENV="$AUDIT_OBJ" python -c 'import os,json; rid=os.environ["RUN_ID_ENV"]; rsha=os.environ["R_SHA_ENV"]; p=os.environ["AUDIT_OBJ_ENV"]; o=json.load(open(p,"r",encoding="utf-8")); assert o.get("run_id")==rid; assert o.get("bundle_sha256")==rsha; print("ok")' || FAIL=1
          done

          if [ "$FAIL" -ne 0 ]; then
            echo "Evidence content validation failed"
            exit 2
          fi

          echo "Evidence content validation passed"

  evidence-pack:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    needs: [report-content]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Verify evidence packs exist for new reports in this PR
        shell: bash
        run: |
          set -euo pipefail

          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          NEW_REPORTS="$(git diff --name-only --diff-filter=A "${BASE_SHA}" "${HEAD_SHA}" -- 'docs/reports/**' || true)"
          if [ -z "$NEW_REPORTS" ]; then
            echo "No new reports added, skipping"
            exit 0
          fi

          for f in $NEW_REPORTS; do
            RUN_ID="$(grep -E "^run_id=" "$f" | head -n 1 | cut -d= -f2 | tr -d "\r\n")"
            ZIP="docs/packs/${RUN_ID}.zip"

            if [ -z "$RUN_ID" ]; then
              echo "Could not extract RUN_ID from $f"
              exit 2
            fi

            if [ ! -f "$ZIP" ]; then
              echo "Missing evidence pack: $ZIP"
              exit 2
            fi

            echo "Pack found: $ZIP"
            unzip -l "$ZIP" | head -n 200
            unzip -l "$ZIP" | grep -Eq '\.json$' || { echo "Pack must contain at least one .json"; exit 2; }
            unzip -l "$ZIP" | grep -Eq '\.(md|txt)$' || { echo "Pack must contain at least one .md or .txt"; exit 2; }
          done

          echo "Evidence pack validation passed"

  upload-evidence-packs:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    needs: [evidence-pack]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/upload-artifact@v4
        with:
          name: evidence-packs
          path: docs/packs/*.zip
          if-no-files-found: error

  main-push-smoke:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Smoke verify Makefile and promote dry-run
        shell: bash
        run: |
          set -euo pipefail
          test -f Makefile
          make -n promote RUN_ID=dummy >/dev/null
          echo ok
